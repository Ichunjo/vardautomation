import abc
from .language import Lang
from .types import AnyPath
from .vpathlib import VPath
from abc import ABC, abstractmethod
from fractions import Fraction
from typing import Any, List, NamedTuple, NoReturn, Optional, Sequence, Type

class Chapter(NamedTuple):
    name: str
    start_frame: int
    end_frame: Optional[int]
    lang: Lang

class Chapters(ABC, metaclass=abc.ABCMeta):
    chapter_file: VPath
    def __init__(self, chapter_file: AnyPath) -> None: ...
    @abstractmethod
    def create(self, chapters: List[Chapter], fps: Fraction) -> None: ...
    @abstractmethod
    def set_names(self, names: Sequence[Optional[str]]) -> None: ...
    @abstractmethod
    def to_chapters(self, fps: Fraction, lang: Optional[Lang]) -> List[Chapter]: ...
    def copy(self, destination: AnyPath) -> None: ...
    def create_qpfile(self, qpfile: AnyPath, fps: Fraction) -> None: ...

class OGMChapters(Chapters):
    chapter_file: Any
    def __init__(self, chapter_file: AnyPath) -> None: ...
    def create(self, chapters: List[Chapter], fps: Fraction) -> None: ...
    def set_names(self, names: Sequence[Optional[str]]) -> None: ...
    def shift_times(self, frames: int, fps: Fraction) -> None: ...
    def to_chapters(self, fps: Fraction, lang: Optional[Lang]) -> List[Chapter]: ...

class MatroskaXMLChapters(Chapters):
    fps: Fraction
    chapter_file: Any
    def __init__(self, chapter_file: AnyPath) -> None: ...
    def create(self, chapters: List[Chapter], fps: Fraction) -> None: ...
    def set_names(self, names: Sequence[Optional[str]]) -> None: ...
    def shift_times(self, frames: int, fps: Fraction) -> None: ...
    def to_chapters(self, fps: Fraction, lang: Optional[Lang] = ...) -> List[Chapter]: ...

class MplsChapters(Chapters):
    m2ts: VPath
    chapters: List[Chapter]
    fps: Fraction
    def create(self, chapters: List[Chapter], fps: Fraction) -> NoReturn: ...
    def set_names(self, names: Sequence[Optional[str]]) -> NoReturn: ...
    def to_chapters(self, fps: Optional[Fraction] = ..., lang: Optional[Lang] = ...) -> List[Chapter]: ...

class IfoChapters(Chapters):
    chapters: List[Chapter]
    fps: Fraction
    def create(self, chapters: List[Chapter], fps: Fraction) -> NoReturn: ...
    def set_names(self, names: Sequence[Optional[str]]) -> NoReturn: ...
    def to_chapters(self, fps: Optional[Fraction] = ..., lang: Optional[Lang] = ...) -> List[Chapter]: ...

class MplsReader:
    bd_folder: VPath
    mpls_folder: VPath
    m2ts_folder: VPath
    lang: Lang
    default_chap_name: str
    class MplsFile(NamedTuple):
        mpls_file: VPath
        mpls_chapters: List[MplsChapters]
    def __init__(self, bd_folder: AnyPath = ..., lang: Lang = ..., default_chap_name: str = ...) -> None: ...
    def get_playlist(self) -> List[MplsFile]: ...
    def write_playlist(self, output_folder: Optional[AnyPath] = ..., *, chapters_obj: Type[Chapters] = ...) -> None: ...
    def parse_mpls(self, mpls_file: AnyPath) -> List[MplsChapters]: ...

class IfoReader:
    dvd_folder: VPath
    ifo_folder: VPath
    lang: Lang
    default_chap_name: str
    def __init__(self, dvd_folder: AnyPath = ..., lang: Lang = ..., default_chap_name: str = ...) -> None: ...
    def write_programs(self, output_folder: Optional[AnyPath] = ..., *, chapters_obj: Type[Chapters] = ..., ifo_file: str = ...) -> None: ...
    def parse_ifo(self, ifo_file: AnyPath) -> List[IfoChapters]: ...
